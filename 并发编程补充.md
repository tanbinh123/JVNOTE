---
title: 并发编程补充
date: 2019-05-03 16:49:12
tags: CSDN迁移
---
 [ ](http://creativecommons.org/licenses/by-sa/4.0/) 版权声明：本文为博主原创文章，遵循[ CC 4.0 by-sa ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。  本文链接：[https://blog.csdn.net/MOKEXFDGH/article/details/89760966](https://blog.csdn.net/MOKEXFDGH/article/details/89760966)   
    
  ### 文章目录


      * [volatile 与 synchronized 的区别](#volatile__synchronized__3)
      * [并行与并发的区别](#_13)
      * [锁、volatile 和 synchronized 如何保持可见性](#volatile__synchronized__18)
      * [内存泄露与内存溢出](#_27)
      * [线程间通信和进程间通信](#_38)  


 
--------
 
### []()volatile 与 synchronized 的区别

 **修饰区域**  
 volatile 轻量级，只能修饰变量  
 synchronized 重量级，修饰变量和方法

 **线程安全**  
 线程安全包括两个方面：可见性、原子性  
 volatile 只能保证数据的可见性，所以不能用来同步；而 synchronized 因为只有获得锁才能进入临界区所以即保证可见性，也保证原子性。

 
--------
 
### []()并行与并发的区别

 **并行：** 两个任务同时运行，即 A 任务进行的同时，B 任务也在进行。  
 **并发：** 两个任务都请求运行，而处理器只能接受一个任务，于是就把这两个任务安排轮流进行，由于时间间隔短，所以感觉是两个任务都在运行。

 
--------
 
### []()锁、volatile 和 synchronized 如何保持可见性

 **锁和 synchronized：**  
 一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由 happen-before 原则推断出在读操作之前发生。

 **volatile：**  
 每次访问变量时都会进行一次内存的刷新，保证访问的都是主内存中最新的版本。  
 **注：** 在多线程需要访问的成员变量上使用 volatile；当变量已在 synchronized 中或为常量时，则不用使用 volatile。

 
--------
 
### []()内存泄露与内存溢出

 **内存泄露：** 指无用对象持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费。严重时会提示 Out of memory。

 **内存溢出：** 指程序运行过程中无法申请到足够的内存而导致的一种错误。内存泄露最终也会造成内存溢出错误。

 **产生内存泄露的几种原因类型：**

  
  2. **静态集合类：** set、vector、hashmap等，当被定义成静态时，生命周期和应用程序一样长，容易发生内存泄露。 
  4. **数据库、网络、IO等连接** 都需要显示地调用其 close() 方法将连接关闭，否则 Connection 等这些对象不会自动被 GC 回收，从而引起内存泄露。 
  6. **单例模式：** 单例对象存在于 JVM 整个生命周期，而如果它持有一个生命周期比较短的外部对象，那么这个外部对象就一直不能够被回收，从而导致内存泄露。  
--------
 
### []()线程间通信和进程间通信

 **线程间通信：**

  
  * 共享变量：synchronized 同步、while轮询方式 
  * 条件变量：Lock/Condition机制、wait/notify机制 
  * 管道：PiedInputStream 和 PipedOutputStream  **进程间通信：IPC**

  
  * **管道：** 无名管道，用于具有亲缘关系的进程之间的通信，存在于内存中。 
  * **FIFO：** 命名管道，具有管道的功能且能在无关的进程之间交换数据，存在于文件系统中。 
  * **消息队列：** 提供一个队列，拥有权限的进程都可以向队列中添加消息，而拥有读权的进程可以读走队列中的消息，存放在内核中。 
  * **信号量：** 用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 
  * **共享内存：** 多个进程可以访问同一块内存空间，是最快的可用IPC形式。    
  